---
title: 情人节表白神器
date: 2020-02-13 22:09:32
tags: [notes,Python]
categories: 生活
---
## 单身时节又逢君

“都2020年了，这么浪漫的年份，你还是一个人吗？”

“难不成我还能是一条狗？”

嘻嘻嘻，祝大家情人节快乐呀！虽然疫情使得大家在这个情人节被异地了，甚至于成为小哥哥小姐姐们脱单之路上的拦路虎，但是我们可以更多点联系与互动，来表达自己的喜爱与思念呀，比如~线上表白系列来咯！ *^O^* 

<!--more-->
## 用Python助你脱单

今天在微信公众号看到一篇推文，[情人节来了，教你个用Python表白的技巧](https://mp.weixin.qq.com/s/KPEyh_SvvphRiw-ZfMcIHw "情人节来了，教你个用Python表白的技巧")，感觉还挺有意思的。看完文章我也亲自实验了一下，制作了几张表白图片发给小姐妹，嘻嘻，撩妹技能+1。源码也附上了，大家只要对应改下自己的图片路径就能实现啦！字体样式和大小也可以按照自己心意修改。

以下是文章内容，包括技术分析和代码实现：

明哥今天来教你如何使用 Python 来向心中的女神表白。
前段时间，在微博上刷到了一条推荐。内容是这样的：
![微博图片](1.jpg "微博图片")
出于好奇，我点开了，放大再放大，emmm，有点意思吖…
![放大图片](2.jpg "放大图片")

这四个字，对于像我这样腼腆的DS男来说，还真不好意思说，说出来，万一被拒绝了咋办？

使用套路来表白，并观察对方的反应，你大概能清楚对方是否对你也有好感，先测试下自己有几成的把握再下手或许更稳妥。

今天就教大家一个这样的套路：如何使用 Python 来做出来这样的图，有点浪漫，又有点极客。能不能拿下你女神，就要靠你（命）了。(๑•́₃ •̀๑)

### 思路分析

首先，你得先找到一张你女神的高清图片（尽量分辨率高点的吧，效果会好点）。

这里我以一张高圆圆的图来做一下演示，原图是这样的（分辨率是：2000*1328）。
![高圆圆原图](3.jpg "高圆圆原图")
使用我写好的脚本运行后，就生成了这样一张图，请你点击，放大再放大。（惊喜？
![高圆圆生成图](4.jpg "高圆圆生成图")

然后将这张图片发给你的女神，具体话术你自己想咯。

好吧，相比女神来说，你可能更在意这是如何实现的（活该你单身）。

其实原理很简单，代码也还不到20 行。

首先，来讲讲原理。

事实上，每一张图片都是由一个一个的像素点所组成的。而每个像素点，都有自己的颜色，其颜色可以用一个数组来表示：(a,b,c)，其中每位数的取值范围都是 0-255。

比如(0,0,0)代表黑色，(255,255,255)代表白色。

当像素点足够多的时候，这张照片就是我们所说的高清照片。

而如果当像素点太少，我们的肉眼就能感知到明显的锯齿感。

用 Excel 画了个图，每一方格代表一个像素，其中若我的字体的大小设置 5（非字号5，而是每个字占用5个像素），效果大概就是如下这样子。
![我喜欢你](5.png "我喜欢你")
我只要每个像素取出一个像素值，并使用这个像素做为该字的颜色即可，在像素量够多的情况下，从远处看，是能看到我们原来图像的轮廓的。

有了思路，就可以开始我们的代码。


### 代码实现

首先，使用 pillow.Image读取图像，并使用load函数获取到每一个像素值。
```python
img_raw = Image.open(img_path)
img_array = img_raw.load()
```

然后新建一张画布，并选好你要使用的字体和字体大小。
```python
img_new = Image.new("RGB", img_raw.size, (0, 0, 0))
draw = ImageDraw.Draw(img_new)
font = ImageFont.truetype('C:/Windows/fonts/Dengl.ttf', font_size)
```

由于需要不断循环 “我喜欢你！”，这五个字符。所以这里可以while循环 yield 来实现一个生成器。
```python
def character_generator(text):
    while True:
        for i in range(len(text)):
            yield text[i]
```

最后，要给这些字加上相应的颜色，写入新创建的画布中。
```python
for y in range(0, img_raw.size[1], font_size):
    for x in range(0, img_raw.size[0], font_size):
        draw.text((x, y), next(ch_gen), font=font, fill=img_array[x, y], direction=None)
```

最后将成品保存
```python
img_new.convert('RGB').save("F://gyy_save.jpeg")
```
### 完整代码

完整代码如下，供你参考
```python
from PIL import Image, ImageDraw, ImageFont  
# 需安装pillow

font_size = 13    # 字体大小
text = "我喜欢你！"   # 文本内容，可更换
img_path = "D://Users//Lynn//Pictures//Photos//Q3.jpg"   # 图片路径,需要更换

# 图片及像素点加载
img_raw = Image.open(img_path)
img_array = img_raw.load()

# 新画布，背景黑色
img_new = Image.new("RGB", img_raw.size, (0, 0, 0))
draw = ImageDraw.Draw(img_new)
font = ImageFont.truetype('C:/Windows/Fonts/STXINGKA.TTF', font_size)  # 字体

def character_generator(text):
    while True:
        for i in range(len(text)):
            yield text[i]
        
ch_gen = character_generator(text)

for y in range(0, img_raw.size[1], font_size):
    for x in range(0, img_raw.size[0], font_size):
        draw.text((x,y), next(ch_gen), font=font, fill=img_array[x,y], direction=None)

img_new.convert('RGB').save("D://Users//Lynn//Pictures//Photos//Q3_save.jpg")
```
### 效果图
最后再多上几张效果图吧（对，我是海贼迷）。
1.路飞
![路飞](6.jpg "路飞")
2.索隆
![索隆](7.jpg "索隆")
3.山治
![山治](8.jpg "山治")

## 助你避坑，祝你成功

以下是我(Lynn)实验过程中遇到的一点小小问题，因为是新电脑，重新安装的Python环境，所以python小白一定不要错过呀，补充在这里希望大家避坑*^O^*~

* Q1：无 module PIL 
当然是先安装PIL啦！因为PIL包含在pillow中，所以直接安装pillow就好。
网上也有相应pillow安装，直接`pip install PIL`就好，但是安装过程中会报错：
```
ERROR: Could not find a version that satisfies the requirement PTL (from versions: none)
ERROR: No matching distribution found for PTL
```
后来我找到一个有用的解决方法：

首先，找一个非官方的64位大家通用的PIL安装，打开网址 <http://www.lfd.uci.edu/~gohlke/pythonlibs/>(比较慢，大家耐心等一等),搜索PIL（ctrl+F），找到下面的图片所示，如果你的python是2.7版本就下载cp27的，3.7就下载cp37.
![Pillow](9.png "Pillow_SIMD-7.0.0.post3-cp37-cp37m-win_amd64.whl")

还要先安装wheel，打开cmd（win+r），你要先安装pip，具体pip怎么安装这里有很详细的教程[Python pip安装与使用](https://www.runoob.com/w3cnote/python-pip-install-usage.html)，输入`pip install wheel`后显示安装成功即可。
wheel安装好后，找到我们下载好的相应版本的Pillow_SIMD-7.0.0.post3-cp37-cp37m-win_amd64.whl（这是我的版本），我把它放到了C盘用户目录下(cmd中一定要在当前路径下安装)，所以我打开cmd后，直接pip安装即`pip install Pillow_SIMD-7.0.0.post3-cp37-cp37m-win_amd64.whl`就成功了，会显示安装成功，因为我已经安装成功了，后来再安装会显示如下：
![Pillow安装成功](10.png "安装成功")

成功后就可以直接使用啦！

* Q2:图片路径问题
一定要注意图片路径，直接复制文件资源管理器之后路径是`D:\Users\Lynn\Pictures\Photos、Q3.jpg`，这里需要改为`D://Users//Lynn//Pictures//Photos//Q3.jpg`，即把'\'改成'//'。

* Q3；图片全黑
最后脚本代码也不报错啦，图片也生成啦，可是图片上怎么全黑的呢？文本哪里去了呢？
原因如下：图片全黑是因为背景色用的是黑(0，0，0)，这个是可以在下面代码中改的：`img_new = Image.new("RGB", img_raw.size, (0, 0, 0))`

那么字体不显示则是因为字体路径出错或者是字体源文件不存在，因为你的电脑中可能没有源作者用的特殊字体，具体解决方法是：windows系统在路径`C：/Windows/fonts/`下，找一个字体文件，点击右键查看属性(一定要查看属性名带后缀)，里面有真实的字体英文名，查看不了属性的字体不要使用，用了就是图片全黑。

最后运行脚本，去对应目录下查看生成的表白图片就可以啦！
代码我运行过是没有问题的，大家copy后修改下图片路径就OK。所以这里展示的是不使用编辑器直接在cmd中调用python脚本运行的方式：
![生成表白图片](11.png "生成表白图片")

**图片大小和文本大小会影响图片生成速度哦！**

## 更新：批量处理

这里是在阅读崔庆才老师更文，文章提供的修改成批量处理方式的代码。应用于你有多张图片需要生成时,可以放到inputs文件夹下，它会顺次处理并输出到outputs文件夹下，也不用再一个个定义图片名称啦。

其中增加了一个参数叫做font_space，原来的代码生成的字可能会有点紧凑，这里增加这个参数可以控制字与字之间的距离，比如font_size=1，字间距就是字的大小，排布紧密，如果改大一点比如font_size=1。2，字间距就会变成字的1.2倍，会留有字大小的0.2倍的空隙。

###  完整代码
```python
from PIL import Image, ImageDraw, ImageFont
from glob import glob
from os.path import basename, join

# 字体大小
font_size = 9

# 字体间距， 1 间距正好为字体大小，紧凑排布； 1.2 为字体大小的1.2倍
font_space = 1.2

# 绘制文本
text = "我喜欢你！"

# 字体文件的路径
font_file = 'C:/Windows/Fonts/STXINGKA.TTF'

# 输入图片路径
inputs_folder = "D://Users//Lynn//Pictures//Photos//multi//inputs"  # 此处更换自己原图路径

# 输出图片路径
outputs_folder = "D://Users//Lynn//Pictures//Photos//multi//outputs"    # 此处更换生成图片路径
    
def process(path):
    img_raw = Image.open(path)
    img_array = img_raw.load()
    img_new = Image.new('RGB', img_raw.size, (0,0,0))
    draw = ImageDraw.Draw(img_new)
    font = ImageFont.truetype(font_file,size=font_size)

    def character_generator(text):
        while True:
            for i in range(len(text)):
                yield text[i]
    
    ch_gen = character_generator(text)

    for y in range(00, img_raw.size[1], font_size):
        for x in range(0, img_raw.size[0], int(font_size * font_space)):
            draw.text((x,y), next(ch_gen), font=font, fill=img_array[x,y], direction=None)
        
    img_new.convert('RGB').save(join(outputs_folder, basename(path)))

if __name__ == '__main__':
    for path in glob(join(inputs_folder, '*')):
        print("starting processing", path)
        process(path)
        print("finished processing", path)
```

**最后祝各位成功脱单！**